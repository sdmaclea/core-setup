From b3fd9e581656b059d79361d6a228a3f1a2f5edba Mon Sep 17 00:00:00 2001
From: Steve MacLean <sdmaclea.qdt@qualcommdatacenter.com>
Date: Thu, 25 Jan 2018 16:55:04 -0500
Subject: [PATCH] Revert "[Arm64] HW Intrinsics Short Vector ABI"

This reverts commit 6720fe0f83e01c494bd082203cf5c2a8dddc4b5f.
---
 src/jit/compiler.cpp         | 35 -----------------------------------
 src/jit/compiler.h           |  3 ---
 src/jit/gentree.cpp          |  4 ----
 src/jit/hwintrinsicArm64.cpp | 21 ---------------------
 src/jit/lclvars.cpp          | 10 ----------
 src/jit/morph.cpp            |  3 ---
 6 files changed, 76 deletions(-)

diff --git a/src/jit/compiler.cpp b/src/jit/compiler.cpp
index b9a1859..fd3264e 100644
--- a/src/jit/compiler.cpp
+++ b/src/jit/compiler.cpp
@@ -632,13 +632,6 @@ var_types Compiler::getPrimitiveTypeForStruct(unsigned structSize, CORINFO_CLASS
 #endif // _TARGET_64BIT_
 
         case TARGET_POINTER_SIZE:
-#if defined(FEATURE_HW_INTRINSICS) && defined(_TARGET_ARM64_)
-            if (IsShortVector(clsHnd))
-            {
-                useType = TYP_SIMD8;
-                break;
-            }
-#endif // defined(FEATURE_HW_INTRINSICS) && defined(_TARGET_ARM64_)
 #ifdef ARM_SOFTFP
             // For ARM_SOFTFP, HFA is unsupported so we need to check in another way
             // This matters only for size-4 struct cause bigger structs would be processed with RetBuf
@@ -681,18 +674,6 @@ var_types Compiler::getPrimitiveTypeForStruct(unsigned structSize, CORINFO_CLASS
             }
             break;
 
-#if defined(FEATURE_HW_INTRINSICS) && defined(_TARGET_ARM64_)
-        case FP_REGSIZE_BYTES:
-            if (IsShortVector(clsHnd))
-            {
-                useType = TYP_SIMD16;
-            }
-            else
-            {
-                useType = TYP_UNKNOWN;
-            }
-#endif // defined(FEATURE_HW_INTRINSICS) && defined(_TARGET_ARM64_)
-
 #ifdef _TARGET_ARM_
         case 8:
             if (IsHfa(clsHnd))
@@ -804,19 +785,11 @@ var_types Compiler::getArgTypeForStruct(CORINFO_CLASS_HANDLE clsHnd,
 
 #else // all other targets
 
-#if defined(FEATURE_HW_INTRINSICS) && defined(_TARGET_ARM64_)
-    // The largest primitive type is 16 bytes (TYP_SIMD16)
-    // so we can skip calling getPrimitiveTypeForStruct when we
-    // have a struct that is larger than that.
-    //
-    if (structSize <= FP_REGSIZE_BYTES)
-#else
     // The largest primitive type is 8 bytes (TYP_DOUBLE)
     // so we can skip calling getPrimitiveTypeForStruct when we
     // have a struct that is larger than that.
     //
     if (structSize <= sizeof(double))
-#endif // defined(FEATURE_HW_INTRINSICS) && defined(_TARGET_ARM64_)
     {
         // We set the "primitive" useType based upon the structSize
         // and also examine the clsHnd to see if it is an HFA of count one
@@ -1034,19 +1007,11 @@ var_types Compiler::getReturnTypeForStruct(CORINFO_CLASS_HANDLE clsHnd,
 
 #else // not UNIX_AMD64
 
-#if defined(FEATURE_HW_INTRINSICS) && defined(_TARGET_ARM64_)
-    // The largest primitive type is 16 bytes (TYP_SIMD16)
-    // so we can skip calling getPrimitiveTypeForStruct when we
-    // have a struct that is larger than that.
-    //
-    if (structSize <= FP_REGSIZE_BYTES)
-#else
     // The largest primitive type is 8 bytes (TYP_DOUBLE)
     // so we can skip calling getPrimitiveTypeForStruct when we
     // have a struct that is larger than that.
     //
     if (structSize <= sizeof(double))
-#endif // defined(FEATURE_HW_INTRINSICS) && defined(_TARGET_ARM64_)
     {
 #if defined LEGACY_BACKEND
         if (!IsHfa(clsHnd))
diff --git a/src/jit/compiler.h b/src/jit/compiler.h
index 34c0a01..5146d4f 100644
--- a/src/jit/compiler.h
+++ b/src/jit/compiler.h
@@ -2087,9 +2087,6 @@ public:
                                                    NamedIntrinsic hwIntrinsicID);
     GenTree* gtNewMustThrowException(unsigned helper, var_types type, CORINFO_CLASS_HANDLE clsHnd);
     CORINFO_CLASS_HANDLE gtGetStructHandleForHWSIMD(var_types simdType, var_types simdBaseType);
-#ifdef _TARGET_ARM64_
-    bool IsShortVector(CORINFO_CLASS_HANDLE hClass);
-#endif //  _TARGET_ARM64_
 #endif // FEATURE_HW_INTRINSICS
 
     GenTreePtr gtNewLclLNode(unsigned lnum, var_types type, IL_OFFSETX ILoffs = BAD_IL_OFFSET);
diff --git a/src/jit/gentree.cpp b/src/jit/gentree.cpp
index e3a05b2..6321b5d 100644
--- a/src/jit/gentree.cpp
+++ b/src/jit/gentree.cpp
@@ -18045,11 +18045,7 @@ void ReturnTypeDesc::InitializeStructReturnType(Compiler* comp, CORINFO_CLASS_HA
         case Compiler::SPK_PrimitiveType:
         {
             assert(returnType != TYP_UNKNOWN);
-#if defined(FEATURE_HW_INTRINSICS) && defined(_TARGET_ARM64_)
-            assert(!varTypeIsStruct(returnType) || comp->IsShortVector(retClsHnd));
-#else
             assert(!varTypeIsStruct(returnType));
-#endif
             m_regType[0] = returnType;
             break;
         }
diff --git a/src/jit/hwintrinsicArm64.cpp b/src/jit/hwintrinsicArm64.cpp
index 7343590..3a49ff9 100644
--- a/src/jit/hwintrinsicArm64.cpp
+++ b/src/jit/hwintrinsicArm64.cpp
@@ -299,25 +299,4 @@ CORINFO_CLASS_HANDLE Compiler::gtGetStructHandleForHWSIMD(var_types simdType, va
     return NO_CLASS_HANDLE;
 }
 
-bool Compiler::IsShortVector(CORINFO_CLASS_HANDLE hClass)
-{
-    if(!isIntrinsicType(hClass))
-    {
-        return false;
-    }
-
-    unsigned  simdSize;
-    var_types simdBaseType = getBaseTypeAndSizeOfSIMDType(hClass, &simdSize);
-
-    if (simdBaseType != TYP_UNKNOWN)
-    {
-        // Current Short Vector logic assumes Vector256 returns TYP_UNKNOWN for ARM64
-        assert((simdSize == FP_REGSIZE_BYTES) || (simdSize == REGSIZE_BYTES));
-        return true;
-    }
-
-    return false;
-}
-
-
 #endif // FEATURE_HW_INTRINSICS
diff --git a/src/jit/lclvars.cpp b/src/jit/lclvars.cpp
index e3bbea1..bc2470c 100644
--- a/src/jit/lclvars.cpp
+++ b/src/jit/lclvars.cpp
@@ -147,11 +147,7 @@ void Compiler::lvaInitTypeRef()
         if (howToReturnStruct == SPK_PrimitiveType)
         {
             assert(returnType != TYP_UNKNOWN);
-#if defined(FEATURE_HW_INTRINSICS) && defined(_TARGET_ARM64_)
-            assert(!varTypeIsStruct(returnType) || IsShortVector(retClsHnd));
-#else
             assert(!varTypeIsStruct(returnType));
-#endif
 
             info.compRetNativeType = returnType;
 
@@ -164,12 +160,6 @@ void Compiler::lvaInitTypeRef()
             {
                 compFloatingPointUsed = true;
             }
-#if defined(FEATURE_HW_INTRINSICS) && defined(_TARGET_ARM64_)
-            else if (((returnType == TYP_SIMD8) || (returnType == TYP_SIMD16)) && (compFloatingPointUsed == false))
-            {
-                compFloatingPointUsed = true;
-            }
-#endif
         }
     }
 
diff --git a/src/jit/morph.cpp b/src/jit/morph.cpp
index f56aafc..b378ff5 100644
--- a/src/jit/morph.cpp
+++ b/src/jit/morph.cpp
@@ -3934,9 +3934,6 @@ GenTreeCall* Compiler::fgMorphArgs(GenTreeCall* call)
                             argObj->gtType = structBaseType;
                         }
                         assert(varTypeCanReg(argObj->TypeGet()) ||
-#if defined(FEATURE_HW_INTRINSICS) && defined(_TARGET_ARM64_)
-                               varTypeIsSIMD(argObj->TypeGet()) ||
-#endif // defined(FEATURE_HW_INTRINSICS) && defined(_TARGET_ARM64_)
                                ((copyBlkClass != NO_CLASS_HANDLE) && varTypeIsIntegral(structBaseType)));
 
                         size = 1;
-- 
2.7.4

