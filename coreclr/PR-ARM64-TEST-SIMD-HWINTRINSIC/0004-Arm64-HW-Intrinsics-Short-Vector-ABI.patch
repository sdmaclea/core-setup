From 57f834a13de023216aed6090e318f15fb6800a9b Mon Sep 17 00:00:00 2001
From: Steve MacLean <sdmaclea.qdt@qualcommdatacenter.com>
Date: Thu, 25 Jan 2018 13:56:29 -0500
Subject: [PATCH] [Arm64] HW Intrinsics Short Vector ABI

---
 src/jit/compiler.cpp         | 35 +++++++++++++++++++++++++++++++++++
 src/jit/compiler.h           |  3 +++
 src/jit/gentree.cpp          |  4 ++++
 src/jit/hwintrinsicArm64.cpp | 21 +++++++++++++++++++++
 src/jit/lclvars.cpp          | 10 ++++++++++
 src/jit/morph.cpp            |  3 +++
 6 files changed, 76 insertions(+)

diff --git a/src/jit/compiler.cpp b/src/jit/compiler.cpp
index fd3264e..b9a1859 100644
--- a/src/jit/compiler.cpp
+++ b/src/jit/compiler.cpp
@@ -632,6 +632,13 @@ var_types Compiler::getPrimitiveTypeForStruct(unsigned structSize, CORINFO_CLASS
 #endif // _TARGET_64BIT_
 
         case TARGET_POINTER_SIZE:
+#if defined(FEATURE_HW_INTRINSICS) && defined(_TARGET_ARM64_)
+            if (IsShortVector(clsHnd))
+            {
+                useType = TYP_SIMD8;
+                break;
+            }
+#endif // defined(FEATURE_HW_INTRINSICS) && defined(_TARGET_ARM64_)
 #ifdef ARM_SOFTFP
             // For ARM_SOFTFP, HFA is unsupported so we need to check in another way
             // This matters only for size-4 struct cause bigger structs would be processed with RetBuf
@@ -674,6 +681,18 @@ var_types Compiler::getPrimitiveTypeForStruct(unsigned structSize, CORINFO_CLASS
             }
             break;
 
+#if defined(FEATURE_HW_INTRINSICS) && defined(_TARGET_ARM64_)
+        case FP_REGSIZE_BYTES:
+            if (IsShortVector(clsHnd))
+            {
+                useType = TYP_SIMD16;
+            }
+            else
+            {
+                useType = TYP_UNKNOWN;
+            }
+#endif // defined(FEATURE_HW_INTRINSICS) && defined(_TARGET_ARM64_)
+
 #ifdef _TARGET_ARM_
         case 8:
             if (IsHfa(clsHnd))
@@ -785,11 +804,19 @@ var_types Compiler::getArgTypeForStruct(CORINFO_CLASS_HANDLE clsHnd,
 
 #else // all other targets
 
+#if defined(FEATURE_HW_INTRINSICS) && defined(_TARGET_ARM64_)
+    // The largest primitive type is 16 bytes (TYP_SIMD16)
+    // so we can skip calling getPrimitiveTypeForStruct when we
+    // have a struct that is larger than that.
+    //
+    if (structSize <= FP_REGSIZE_BYTES)
+#else
     // The largest primitive type is 8 bytes (TYP_DOUBLE)
     // so we can skip calling getPrimitiveTypeForStruct when we
     // have a struct that is larger than that.
     //
     if (structSize <= sizeof(double))
+#endif // defined(FEATURE_HW_INTRINSICS) && defined(_TARGET_ARM64_)
     {
         // We set the "primitive" useType based upon the structSize
         // and also examine the clsHnd to see if it is an HFA of count one
@@ -1007,11 +1034,19 @@ var_types Compiler::getReturnTypeForStruct(CORINFO_CLASS_HANDLE clsHnd,
 
 #else // not UNIX_AMD64
 
+#if defined(FEATURE_HW_INTRINSICS) && defined(_TARGET_ARM64_)
+    // The largest primitive type is 16 bytes (TYP_SIMD16)
+    // so we can skip calling getPrimitiveTypeForStruct when we
+    // have a struct that is larger than that.
+    //
+    if (structSize <= FP_REGSIZE_BYTES)
+#else
     // The largest primitive type is 8 bytes (TYP_DOUBLE)
     // so we can skip calling getPrimitiveTypeForStruct when we
     // have a struct that is larger than that.
     //
     if (structSize <= sizeof(double))
+#endif // defined(FEATURE_HW_INTRINSICS) && defined(_TARGET_ARM64_)
     {
 #if defined LEGACY_BACKEND
         if (!IsHfa(clsHnd))
diff --git a/src/jit/compiler.h b/src/jit/compiler.h
index 5146d4f..34c0a01 100644
--- a/src/jit/compiler.h
+++ b/src/jit/compiler.h
@@ -2087,6 +2087,9 @@ public:
                                                    NamedIntrinsic hwIntrinsicID);
     GenTree* gtNewMustThrowException(unsigned helper, var_types type, CORINFO_CLASS_HANDLE clsHnd);
     CORINFO_CLASS_HANDLE gtGetStructHandleForHWSIMD(var_types simdType, var_types simdBaseType);
+#ifdef _TARGET_ARM64_
+    bool IsShortVector(CORINFO_CLASS_HANDLE hClass);
+#endif //  _TARGET_ARM64_
 #endif // FEATURE_HW_INTRINSICS
 
     GenTreePtr gtNewLclLNode(unsigned lnum, var_types type, IL_OFFSETX ILoffs = BAD_IL_OFFSET);
diff --git a/src/jit/gentree.cpp b/src/jit/gentree.cpp
index 6321b5d..e3a05b2 100644
--- a/src/jit/gentree.cpp
+++ b/src/jit/gentree.cpp
@@ -18045,7 +18045,11 @@ void ReturnTypeDesc::InitializeStructReturnType(Compiler* comp, CORINFO_CLASS_HA
         case Compiler::SPK_PrimitiveType:
         {
             assert(returnType != TYP_UNKNOWN);
+#if defined(FEATURE_HW_INTRINSICS) && defined(_TARGET_ARM64_)
+            assert(!varTypeIsStruct(returnType) || comp->IsShortVector(retClsHnd));
+#else
             assert(!varTypeIsStruct(returnType));
+#endif
             m_regType[0] = returnType;
             break;
         }
diff --git a/src/jit/hwintrinsicArm64.cpp b/src/jit/hwintrinsicArm64.cpp
index 3a49ff9..7343590 100644
--- a/src/jit/hwintrinsicArm64.cpp
+++ b/src/jit/hwintrinsicArm64.cpp
@@ -299,4 +299,25 @@ CORINFO_CLASS_HANDLE Compiler::gtGetStructHandleForHWSIMD(var_types simdType, va
     return NO_CLASS_HANDLE;
 }
 
+bool Compiler::IsShortVector(CORINFO_CLASS_HANDLE hClass)
+{
+    if(!isIntrinsicType(hClass))
+    {
+        return false;
+    }
+
+    unsigned  simdSize;
+    var_types simdBaseType = getBaseTypeAndSizeOfSIMDType(hClass, &simdSize);
+
+    if (simdBaseType != TYP_UNKNOWN)
+    {
+        // Current Short Vector logic assumes Vector256 returns TYP_UNKNOWN for ARM64
+        assert((simdSize == FP_REGSIZE_BYTES) || (simdSize == REGSIZE_BYTES));
+        return true;
+    }
+
+    return false;
+}
+
+
 #endif // FEATURE_HW_INTRINSICS
diff --git a/src/jit/lclvars.cpp b/src/jit/lclvars.cpp
index bc2470c..e3bbea1 100644
--- a/src/jit/lclvars.cpp
+++ b/src/jit/lclvars.cpp
@@ -147,7 +147,11 @@ void Compiler::lvaInitTypeRef()
         if (howToReturnStruct == SPK_PrimitiveType)
         {
             assert(returnType != TYP_UNKNOWN);
+#if defined(FEATURE_HW_INTRINSICS) && defined(_TARGET_ARM64_)
+            assert(!varTypeIsStruct(returnType) || IsShortVector(retClsHnd));
+#else
             assert(!varTypeIsStruct(returnType));
+#endif
 
             info.compRetNativeType = returnType;
 
@@ -160,6 +164,12 @@ void Compiler::lvaInitTypeRef()
             {
                 compFloatingPointUsed = true;
             }
+#if defined(FEATURE_HW_INTRINSICS) && defined(_TARGET_ARM64_)
+            else if (((returnType == TYP_SIMD8) || (returnType == TYP_SIMD16)) && (compFloatingPointUsed == false))
+            {
+                compFloatingPointUsed = true;
+            }
+#endif
         }
     }
 
diff --git a/src/jit/morph.cpp b/src/jit/morph.cpp
index b378ff5..f56aafc 100644
--- a/src/jit/morph.cpp
+++ b/src/jit/morph.cpp
@@ -3934,6 +3934,9 @@ GenTreeCall* Compiler::fgMorphArgs(GenTreeCall* call)
                             argObj->gtType = structBaseType;
                         }
                         assert(varTypeCanReg(argObj->TypeGet()) ||
+#if defined(FEATURE_HW_INTRINSICS) && defined(_TARGET_ARM64_)
+                               varTypeIsSIMD(argObj->TypeGet()) ||
+#endif // defined(FEATURE_HW_INTRINSICS) && defined(_TARGET_ARM64_)
                                ((copyBlkClass != NO_CLASS_HANDLE) && varTypeIsIntegral(structBaseType)));
 
                         size = 1;
-- 
2.7.4

