From 347d7f9fedf0d021dfa6cc9fa6a20d25b0395746 Mon Sep 17 00:00:00 2001
From: Steve MacLean <sdmaclea.qdt@qualcommdatacenter.com>
Date: Thu, 20 Jul 2017 19:06:14 -0400
Subject: [PATCH] Optimize for idle WorkStealingQueueList

When WorkStealingQueue is empty there is an O(N^2)
penalty for searching the empty queues.  Avoid by
stashing global emptiness
---
 src/mscorlib/src/System/Threading/ThreadPool.cs | 29 ++++++++++++++++++++++++-
 1 file changed, 28 insertions(+), 1 deletion(-)

diff --git a/src/mscorlib/src/System/Threading/ThreadPool.cs b/src/mscorlib/src/System/Threading/ThreadPool.cs
index 0084050..4f10e4e 100644
--- a/src/mscorlib/src/System/Threading/ThreadPool.cs
+++ b/src/mscorlib/src/System/Threading/ThreadPool.cs
@@ -47,6 +47,12 @@ namespace System.Threading
 
             public static WorkStealingQueue[] Queues => _queues;
 
+            // Track whether the WorkStealingQueueList is empty
+            // Three states simplifies race conditions.  They may be considered.
+            // Now Active --> Maybe Inactive -> Confirmed Inactive
+            public const int WsqNowActive = 2;
+            public static int wsqActive;
+
             public static void Add(WorkStealingQueue queue)
             {
                 Debug.Assert(queue != null);
@@ -441,6 +447,13 @@ namespace System.Threading
             if (null != tl)
             {
                 tl.workStealingQueue.LocalPush(callback);
+
+                Interlocked.MemoryBarrier();
+
+                if (WorkStealingQueueList.wsqActive != WorkStealingQueueList.WsqNowActive)
+                {
+                    Volatile.Write(ref WorkStealingQueueList.wsqActive, WorkStealingQueueList.WsqNowActive);
+                }
             }
             else
             {
@@ -458,8 +471,11 @@ namespace System.Threading
 
         public IThreadPoolWorkItem Dequeue(ThreadPoolWorkQueueThreadLocals tl, ref bool missedSteal)
         {
-            WorkStealingQueue localWsq = tl.workStealingQueue;
             IThreadPoolWorkItem callback;
+            int wsqActiveObserved = WorkStealingQueueList.wsqActive;
+            if (wsqActiveObserved > 0)
+            {
+                WorkStealingQueue localWsq = tl.workStealingQueue;
 
                 if ((callback = localWsq.LocalPop()) == null && // first try the local queue
                     !workItems.TryDequeue(out callback)) // then try the global queue
@@ -484,6 +500,17 @@ namespace System.Threading
                         }
                         c--;
                     }
+                    if ((callback == null) && !missedSteal)
+                    {
+                        // Only decrement if the value is unchanged since we started looking for work
+                        Interlocked.CompareExchange(ref WorkStealingQueueList.wsqActive, wsqActiveObserved - 1, wsqActiveObserved);
+                    }
+                }
+            }
+            else
+            {
+                // We only need to look at the global queue since WorkStealingQueueList is inactive
+                workItems.TryDequeue(out callback);
             }
 
             return callback;
-- 
2.7.4

