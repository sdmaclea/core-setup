From cb6a9dff5f779c85cf9ca9274caa3401f40c01eb Mon Sep 17 00:00:00 2001
From: Steve MacLean <sdmaclea.qdt@qualcommdatacenter.com>
Date: Thu, 20 Jul 2017 19:06:14 -0400
Subject: [PATCH] Optimize for idle WorkStealingQueueList

When WorkStealingQueue is empty there is an O(N^2)
penalty for searching the empty queues.  Avoid by
stashing global emptiness
---
 src/mscorlib/src/System/Threading/ThreadPool.cs | 27 ++++++++++++++++++++++++-
 1 file changed, 26 insertions(+), 1 deletion(-)

diff --git a/src/mscorlib/src/System/Threading/ThreadPool.cs b/src/mscorlib/src/System/Threading/ThreadPool.cs
index 0084050..e63d6f0 100644
--- a/src/mscorlib/src/System/Threading/ThreadPool.cs
+++ b/src/mscorlib/src/System/Threading/ThreadPool.cs
@@ -47,6 +47,12 @@ namespace System.Threading
 
             public static WorkStealingQueue[] Queues => _queues;
 
+            // Track whether the WorkStealingQueueList is empty
+            // Three states simplifies race conditions.  They may be considered.
+            // Now Active --> Maybe Inactive -> Confirmed Inactive
+            public const int WsqNowActive = 2;
+            public static int wsqActive;
+
             public static void Add(WorkStealingQueue queue)
             {
                 Debug.Assert(queue != null);
@@ -441,6 +447,11 @@ namespace System.Threading
             if (null != tl)
             {
                 tl.workStealingQueue.LocalPush(callback);
+
+                if (Volatile.Read(ref WorkStealingQueueList.wsqActive) != WorkStealingQueueList.WsqNowActive)
+                {
+                    Volatile.Write(ref WorkStealingQueueList.wsqActive, WorkStealingQueueList.WsqNowActive);
+                }
             }
             else
             {
@@ -458,8 +469,11 @@ namespace System.Threading
 
         public IThreadPoolWorkItem Dequeue(ThreadPoolWorkQueueThreadLocals tl, ref bool missedSteal)
         {
-            WorkStealingQueue localWsq = tl.workStealingQueue;
             IThreadPoolWorkItem callback;
+            int wsqActiveObserved = WorkStealingQueueList.wsqActive;
+            if (wsqActiveObserved > 0)
+            {
+                WorkStealingQueue localWsq = tl.workStealingQueue;
 
                 if ((callback = localWsq.LocalPop()) == null && // first try the local queue
                     !workItems.TryDequeue(out callback)) // then try the global queue
@@ -484,6 +498,17 @@ namespace System.Threading
                         }
                         c--;
                     }
+                    if ((callback == null) && !missedSteal)
+                    {
+                        // Only decrement if the value is unchanged since we started looking for work
+                        Interlocked.CompareExchange(ref WorkStealingQueueList.wsqActive, wsqActiveObserved - 1, wsqActiveObserved);
+                    }
+                }
+            }
+            else
+            {
+                // We only need to look at the global queue since WorkStealingQueueList is inactive
+                workItems.TryDequeue(out callback);
             }
 
             return callback;
-- 
2.7.4

