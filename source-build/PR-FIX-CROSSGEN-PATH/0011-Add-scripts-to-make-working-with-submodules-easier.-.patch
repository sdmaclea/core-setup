From 68e9771721b09f147806f17c115580aaf17f87de Mon Sep 17 00:00:00 2001
From: Chris Rummel <crummel@microsoft.com>
Date: Mon, 13 Nov 2017 15:45:02 -0600
Subject: [PATCH] Add scripts to make working with submodules easier. (#283)

* Add scripts to make working with submodules easier.
Fixes #137.
- Make sure submodules are initialized and optionally do this for you.
- Check if submodules match their checked-in hash and optionally update them if they don't.
- Check for untracked changes in submodules and optionally clean them.
- Put which submodule versions we're using into the tarball.

* Address review feedback.

* Add mechanism to clean all submodules.

* Address review comments.
---
 build-source-tarball.sh |   6 ++
 build.ps1               |   5 ++
 build.sh                |   4 ++
 check-submodules.ps1    | 179 ++++++++++++++++++++++++++++++++++++++++++++++++
 check-submodules.sh     | 164 ++++++++++++++++++++++++++++++++++++++++++++
 5 files changed, 358 insertions(+)
 create mode 100644 check-submodules.ps1
 create mode 100755 check-submodules.sh

diff --git a/build-source-tarball.sh b/build-source-tarball.sh
index 535c54b..c58a2e9 100755
--- a/build-source-tarball.sh
+++ b/build-source-tarball.sh
@@ -14,6 +14,7 @@ if [ "${2:-}" == "--skip-build" ]; then
 fi
 
 TARBALL_ROOT=$1
+FULL_TARBALL_ROOT=$(readlink -f $TARBALL_ROOT)
 
 if [ -e "$TARBALL_ROOT" ]; then
     echo "error '$TARBALL_ROOT' exists"
@@ -70,3 +71,8 @@ do
     fi
 done
 
+# Record commits for the source-build repo and all submodules, to aid in reproducibility.
+echo -e "path\tchecked-in\tactual" > $TARBALL_ROOT/commits.txt
+echo -e "source-build\t$(git rev-parse HEAD)\t$(git rev-parse HEAD)" >> $TARBALL_ROOT/commits.txt
+git submodule foreach --quiet --recursive "actual=\$(git rev-parse HEAD); echo -e \"\$toplevel/\$path\t\$sha1\t\$actual\" >> $FULL_TARBALL_ROOT/commits.txt"
+
diff --git a/build.ps1 b/build.ps1
index 34f1bf8..f8d266b 100644
--- a/build.ps1
+++ b/build.ps1
@@ -24,6 +24,11 @@ function Exec-Block([scriptblock]$cmd) {
 $SCRIPT_ROOT = "$PSScriptRoot"
 $SdkVersion = Get-Content (Join-Path $SCRIPT_ROOT "DotnetCLIVersion.txt")
 
+if ([string]::IsNullOrWhiteSpace($env:SOURCE_BUILD_SKIP_SUBMODULE_CHECK) -or $env:SOURCE_BUILD_SKIP_SUBMODULE_CHECK -eq "0" -or $env:SOURCE_BUILD_SKIP_SUBMODULE_CHECK -eq "false")
+{
+  Exec-Block { & $SCRIPT_ROOT\check-submodules.ps1 } | Out-Host
+}
+
 $env:DOTNET_CLI_TELEMETRY_OPTOUT = 1
 $env:DOTNET_SKIP_FIRST_TIME_EXPERIENCE = 1
 $env:DOTNET_MULTILEVEL_LOOKUP = '0'
diff --git a/build.sh b/build.sh
index 0db5c68..f98e19c 100755
--- a/build.sh
+++ b/build.sh
@@ -10,6 +10,10 @@ if [ -z "${HOME:-}" ]; then
     mkdir "$HOME"
 fi
 
+if [[ "${SOURCE_BUILD_SKIP_SUBMODULE_CHECK:-default}" == "default" || $SOURCE_BUILD_SKIP_SUBMODULE_CHECK == "0" || $SOURCE_BUILD_SKIP_SUBMODULE_CHECK == "false" ]]; then
+  source "$SCRIPT_ROOT/check-submodules.sh"
+fi
+
 export DOTNET_CLI_TELEMETRY_OPTOUT=1
 export DOTNET_SKIP_FIRST_TIME_EXPERIENCE=1
 export DOTNET_MULTILEVEL_LOOKUP=0
diff --git a/check-submodules.ps1 b/check-submodules.ps1
new file mode 100644
index 0000000..a08f827
--- /dev/null
+++ b/check-submodules.ps1
@@ -0,0 +1,179 @@
+$answeredAll = $false   # has the user answered "yes to all" to init'ing submodules?
+$ProjectRoot = $PSScriptRoot
+$CleanAllSentinel = "$ProjectRoot\.cleansourcebuildsubmodules"
+# How long to wait between polling for input on ReadKey.
+# This affects apparent responsiveness so setting it fairly low.
+$InputPollingTime = 100 # ms
+$InputCountTimeout = (30 * 1000) / $InputPollingTime # ms
+
+function WaitForInput() {
+  $counter = 0
+  while (-Not [Console]::KeyAvailable -and ($counter++ -lt $InputCountTimeout)) {
+    Start-Sleep -Milliseconds $InputPollingTime
+  }
+  if ([Console]::KeyAvailable) {
+    $k = [Console]::ReadKey()
+    return $k
+  }
+  return $null
+}
+
+# ask for confirmation and initialize a submodule if approved.
+function init_submodule($Path) {
+  $done = $false
+  while (-Not $done) {
+    Write-Warning "submodule $Path does not appear to be initialized."
+    Write-Host "Should I initialize it for you [Y]es / [n]o / [a]ll / [q]uit"
+    $answer = WaitForInput
+    if ($answer -eq $null -or $answer.KeyChar -ieq "a") {
+      $script:answeredAll = $true
+      $done = $true
+      git submodule update --init --recursive $Path
+    }
+    elseif ($answer.KeyChar -ieq "q") {
+      exit 1
+    }
+    elseif ($answer.KeyChar -ieq "y" -or $answer.Key -eq [System.ConsoleKey]::Spacebar -or $answer.Key -eq [System.ConsoleKey]::Enter) {
+      $done = $true
+      git submodule update --init --recursive $Path
+    }
+    elseif ($answer.KeyChar -ieq "n") {
+      $done = $true
+    }
+    else {
+      Write-Host "Didn't understand that ($($answer.KeyChar))"
+    }
+  }
+}
+
+# update a submodule to an expected commit.  We give different messages
+# for being ahead vs being behind or diverged from the expected commit,
+# so this function is parameterized.
+function fix_submodule($Path, $ExpectedSha, $ActualSha, $Message, $Prompt) {
+  $done = $false
+  while (-Not $done) {
+    Write-Warning $Message
+    Write-Host $Prompt
+    $answer = WaitForInput
+    if ($answer -eq $null -or $answer.KeyChar -ieq "n" -or $answer.Key -eq [System.ConsoleKey]::Spacebar -or $answer.Key -eq [System.ConsoleKey]::Enter) {
+      $done = $true
+    }
+    elseif ($answer.KeyChar -ieq "q") {
+      exit 1
+    }
+    elseif ($answer.KeyChar -ieq "y") {
+      # check if we have this commit locally and can skip the fetch
+      git cat-file -e $expectedSha^`{commit`} 2>&1 | Out-Null
+      if ($LastExitCode -ne 0) {
+        git fetch
+      }
+      # double-check, we should have the commit now unless something
+      # weird is going on.
+      git cat-file -e $expectedSha^`{commit`} 2>&1 | Out-Null
+      if ($LastExitCode -ne 0) {
+        Write-Error "commit $expectedSha was not found in $path"
+        Write-Host "The remote may have changed in source-build; run 'git submodule sync' and retry."
+        Write-Host "Are you using a custom remote for this submodule?  You may need to pick up changes from upstream."
+        Write-Host "Canceling remainder of checks."
+        exit 1
+      }
+      git checkout $expectedSha
+      $done = $true
+    }
+    else {
+      Write-Host "Didn't understand that ($($answer.KeyChar))"
+    }
+  }
+}
+
+# clean a submodule if the user approves.
+function clean_submodule($Path, $Message, $Prompt) {
+  $done = $false
+  while (-Not $done) {
+    Write-Warning $Message
+    Write-Host $Prompt
+    $answer = WaitForInput
+    if ($answer -eq $null -or $answer.KeyChar -ieq "n" -or $answer.Key -eq [System.ConsoleKey]::Spacebar -or $answer.Key -eq [System.ConsoleKey]::Enter) {
+      $done = $true
+    }
+    elseif ($answer.KeyChar -ieq "a") {
+      git clean -fxd
+      git reset --hard HEAD
+      New-Item -ItemType File $CleanAllSentinel | Out-Null
+      $done = $true
+    }
+    elseif ($answer.KeyChar -ieq "q") {
+      exit 1
+    }
+    elseif ($answer.KeyChar -ieq "y") {
+      git clean -fxd
+      git reset --hard HEAD
+      $done = $true
+    }
+    else {
+      Write-Host "Didn't understand that ($($answer.KeyChar))"
+    }
+  }
+}
+
+# We use the same script for checking the super-repo and the submodules.
+# Having the first argument be "in-submodule" triggers this submodule behavior.
+if ($args[0] -ieq "in-submodule") {
+  $path = $args[1]
+  $expectedSha = $args[2]
+  $subcommit = git rev-parse HEAD
+  if ($subcommit -ne $expectedSha) {
+    # merge-base fails if the commit is missing, so check for that first.
+    git cat-file -e $expectedSha^`{commit`} 2>&1 | Out-Null
+    if ($LastExitCode -ne 0) {
+      $mergeBase = "missing commit"
+    }
+    else {
+      $mergeBase = git merge-base HEAD $expectedSha
+    }
+    if ($mergeBase -ne $expectedSha) {
+      fix_submodule -Path $path -ExpectedSha $expectedSha -ActualSha $subcommit -Message "submodule $path, currently at $subcommit, has diverged from checked-in version $expectedSha" -Prompt "If you are changing a submodule branch or moving a submodule backwards, this is expected.`r`nShould I checkout $path to the expected commit $expectedSha [N]o / [y]es / [q]uit"
+    }
+    else {
+      fix_submodule -Path $path -ExpectedSha $expectedSha -ActualSha $subcommit -Message "submodule $path, currently at $subcommit, is ahead of checked-in version $expectedSha" -Prompt "If you are updating a submodule, this is expected.`r`nShould I checkout $path to the expected commit $expectedSha [N]o / [y]es / [q]uit"
+    }
+  }
+  $dirty = $false
+  # check for staged changes and unstaged modifications
+  git diff-index --quiet HEAD --
+  $dirty = $dirty -or $LastExitCode
+  # check for untracked new files
+  $untracked = git ls-files --others --exclude-standard
+  $dirty = $dirty -or (-Not [string]::IsNullOrWhitespace($untracked))
+  if ($dirty) {
+    if (Test-Path $CleanAllSentinel) {
+      git clean -fxd
+      git reset --hard HEAD
+    }
+    else {
+      clean_submodule -Path $path -Message "submodule $path has uncommitted changes" -Prompt "Should I clean and reset $path (this will lose ALL uncommitted changes)? [N]o / [y]es / [a]ll / [q]uit"
+    }
+  }
+}
+# Main branch for super-repo behavior
+else {
+  # submodule foreach doesn't work until submodules are init'd, read the modules manually
+  $modules = git config --file $ProjectRoot\.gitmodules --get-regexp path
+  foreach ($m in $modules) {
+    $m = $m.Split(' ')[1]
+    $mWin = $m.Replace('/', '\')
+    if (-Not (Test-Path "$ProjectRoot\$mWin\.git")) {
+      if ($script:answeredAll) {
+        git submodule update --init --recursive $m
+      }
+      else {
+        init_submodule -Path $m
+      }
+    }
+  }
+  $ProjectRoot = $ProjectRoot.Replace('\', '/')
+  # kick off the submodule behavior for each repo
+  Remove-Item -Force -ErrorAction SilentlyContinue $CleanAllSentinel
+  git submodule foreach --quiet --recursive "powershell $ProjectRoot/check-submodules.ps1 in-submodule `$path `$sha1"
+  Remove-Item -Force -ErrorAction SilentlyContinue $CleanAllSentinel
+}
diff --git a/check-submodules.sh b/check-submodules.sh
new file mode 100755
index 0000000..b7e30f5
--- /dev/null
+++ b/check-submodules.sh
@@ -0,0 +1,164 @@
+#!/bin/bash
+set -euo pipefail
+IFS=$'\n\t'
+
+SCRIPT_ROOT="$(cd -P "$( dirname "$0" )" && pwd)"
+SUBMODULES="$SCRIPT_ROOT/.gitmodules"
+CLEAN_ALL_SENTINEL="$SCRIPT_ROOT/.cleansourcebuildsubmodules"
+PROMPT_TIMEOUT=30
+
+# has the user answered "yes to all" to init'ing submodules?
+answered_all=0
+
+# ask for confirmation and initialize a submodule if approved.
+init_submodule () {
+  module=$1
+  done=0
+  while [ $done == 0 ]; do
+    noreply=0
+    echo "warning: submodules $module does not appear to be initialized."
+    read -p "Should I initialize it for you? [Y]es / [n]o / [a]ll / [q]uit] " -n 1 -r -t $PROMPT_TIMEOUT || noreply=1
+    echo
+    if [[ $noreply == 1 || $REPLY =~ ^[Aa]$ ]]; then
+      answered_all=1
+      done=1
+      git submodule update --init --recursive "$module"
+    elif [[ $REPLY =~ ^[Qq]$ ]]; then
+      exit 0
+    elif [[ $REPLY =~ ^[Nn]$ ]]; then
+      done=1
+    elif [[ $REPLY == "" || $REPLY == " " || $REPLY =~ ^[Yy]$ ]]; then
+      done=1
+      git submodule update --init --recursive "$module"
+    else
+      echo "didn't understand that ($REPLY)"
+    fi
+  done
+}
+
+# update a submodule to an expected commit.  We give different messages
+# for being ahead vs being behind or diverged from the expected commit,
+# so this function is parameterized.
+fix_submodule () {
+  path="$1"
+  expected=$2
+  actual=$3
+  msg="$4"
+  prompt="$5"
+  done=0
+  while [ $done == 0 ]; do
+    noreply=0
+    echo -e "$msg"
+    read -p "$prompt " -n 1 -r -t $PROMPT_TIMEOUT || noreply=1
+    echo
+    if [[ $noreply == 1 || $REPLY == "" || $REPLY == " " || $REPLY =~ ^[Nn]$ ]]; then
+      done=1
+    elif [[ $REPLY =~ ^[Qq]$ ]]; then
+      exit 1
+    elif [[ $REPLY =~ ^[Yy]$ ]]; then
+      # check if we have this commit locally and can skip the fetch
+      git cat-file -e $expected^{commit} 2>/dev/null || exitCode=$?
+      if [ $exitCode != 0 ]; then
+        git fetch
+      fi
+      exitCode=0
+      # double-check, we should have the commit now unless something
+      # weird is going on.
+      git cat-file -e $expected^{commit} 2>/dev/null || exitCode=$?
+      if [ $exitCode != 0 ]; then
+        echo "error: commit $expected was not found in $path"
+        echo "The remote may have changed in source-build; run 'git submodule sync' and retry."
+        echo "Are you using a custom remote for this submodule?  You may need to pick up changes from upstream."
+        echo "Canceling remainder of checks."
+        exit 1
+      fi
+      git checkout $expected
+      done=1
+    else
+      echo "didn't understand that ($REPLY)"
+    fi
+  done
+}
+
+# clean a submodule if the user approves.
+clean_submodule() {
+  path="$1"
+  msg="$2"
+  prompt="$3"
+  done=0
+  while [ $done == 0 ]; do
+    noreply=0
+    echo -e "$msg"
+    read -p "$prompt " -n 1 -r -t $PROMPT_TIMEOUT || noreply=1
+    echo
+    if [[ $noreply == 1 || $REPLY == "" || $REPLY == " " || $REPLY =~ ^[Nn]$ ]]; then
+      done=1
+    elif [[ $REPLY =~ ^[Aa]$ ]]; then
+      git clean -fxd
+      git reset --hard HEAD
+      touch "$CLEAN_ALL_SENTINEL"
+      done=1
+    elif [[ $REPLY =~ ^[Qq]$ ]]; then
+      exit 1
+    elif [[ $REPLY =~ ^[Yy]$ ]]; then
+      git clean -fxd
+      git reset --hard HEAD
+      done=1
+    else
+      echo "didn't understand that ($REPLY)"
+    fi
+  done
+}
+
+# We use the same script for checking the super-repo and the submodules.
+# Having the first argument be "in-submodule" triggers this submodule behavior.
+if [ ${1:-default} == "in-submodule" ]; then
+  path="$2"
+  expected_sha=$3
+  subcommit=`git rev-parse HEAD`
+  if [ "$subcommit" != "$expected_sha" ]; then
+    exitCode=0
+    # merge-base fails if the commit is missing, so check for that first.
+    git cat-file -e $expected_sha^{commit} 2>/dev/null || exitCode=$?
+    if [ $exitCode != 0 ]; then
+      mergeBase="missing commit"
+    else
+      mergeBase=$(git merge-base HEAD $expected_sha)
+    fi
+    if [ "$mergeBase" != "$expected_sha" ]; then
+      fix_submodule $path $expected_sha $subcommit "warning: submodule $path, currently at $subcommit, has diverged from checked-in version $expected_sha\nif you are changing a submodule branch or moving a submodule backwards, this is expected.\nShould I checkout $path to the expected commit $expected_sha?" "[N]o / [y]es / [q]uit"
+    else
+      fix_submodule $path $expected_sha $subcommit "warning: submodule $path, currently at $subcommit, is ahead of checked-in version $expected_sha\nif you are updating a submodule, this is expected.\nShould I checkout $path to the expected commit $expected_sha?" "[N]o / [y]es / [q]uit"
+    fi
+  fi
+  # check for staged changes and unstaged modifications
+  git diff-index --quiet HEAD -- || exit_code=$?
+  # check for untracked new files
+  untracked="$(git ls-files --others --exclude-standard)"
+  if [[ ${exit_code:-0} != 0 || ! -z "$untracked" ]]; then
+    if [ -e "$CLEAN_ALL_SENTINEL" ]; then
+      git clean -fxd
+      git reset --hard HEAD
+    else
+      clean_submodule $path "warning: submodule $path has uncommitted changes\nShould I clean and reset $path (this will lose ALL uncommitted changes)?" "[N]o / [y]es / [a]ll / [q]uit"
+    fi
+  fi
+# Main branch for super-repo behavior
+else
+  # submodule foreach doesn't work until submodules are init'd, read the modules manually
+  for module in `git config --file "$SUBMODULES" --get-regexp path | awk '{ print $2 }'`
+  do
+    if [ ! -e "$SCRIPT_ROOT/$module/.git" ]; then
+      if [ $answered_all == 1 ]; then
+        git submodule update --init --recursive "$module"
+      else
+        init_submodule "$module"
+      fi
+    fi
+  done
+  # kick off the submodule behavior for each repo
+  rm -f "$CLEAN_ALL_SENTINEL"
+  git submodule foreach --quiet --recursive "$SCRIPT_ROOT/check-submodules.sh in-submodule \"\$path\" \"\$sha1\""
+  rm -f "$CLEAN_ALL_SENTINEL"
+fi
+
-- 
2.7.4

